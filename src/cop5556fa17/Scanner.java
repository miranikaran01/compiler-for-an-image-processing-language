package cop5556fa17;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

public class Scanner {

  private HashMap<String, Kind> keywords;

  @SuppressWarnings("serial")
  public static class LexicalException extends Exception {

    int pos;

    public LexicalException(String message, int pos) {
      super(message);
      this.pos = pos;
    }

    public int getPos() {
      return pos;
    }
  }
  public static enum Kind {
    IDENTIFIER, INTEGER_LITERAL, BOOLEAN_LITERAL, STRING_LITERAL, KW_x /* x */, KW_X /* X */, KW_y /* y */,
    KW_Y /* Y */, KW_r /* r */, KW_R /* R */, KW_a /* a */, KW_A /* A */, KW_Z /* Z */, KW_DEF_X /* DEF_X */,
    KW_DEF_Y /* DEF_Y */, KW_SCREEN /* SCREEN */, KW_cart_x /* cart_x */, KW_cart_y /* cart_y */,
    KW_polar_a /* polar_a */, KW_polar_r /* polar_r */, KW_abs /* abs */, KW_sin /* sin */, KW_cos /* cos */,
    KW_atan /* atan */, KW_log /* log */, KW_image /* image */, KW_int /* int */, KW_boolean /* boolean */,
    KW_url /* url */, KW_file /* file */, OP_ASSIGN /* = */, OP_GT /* > */, OP_LT /* < */, OP_EXCL /* ! */,
    OP_Q /* ? */, OP_COLON /* : */, OP_EQ /* == */, OP_NEQ /* != */, OP_GE /* >= */, OP_LE /* <= */,
    OP_AND /* & */, OP_OR /* | */, OP_PLUS /* + */, OP_MINUS /* - */, OP_TIMES /* * */, OP_DIV /* / */,
    OP_MOD /* % */, OP_POWER /* ** */, OP_AT /* @ */, OP_RARROW /* -> */, OP_LARROW /* <- */, LPAREN /* ( */,
    RPAREN /* ) */, LSQUARE /* [ */, RSQUARE /* ] */, SEMI /* ; */, COMMA /* , */, EOF;
  }

  /**
   * Class to represent Tokens.
   * 
   * This is defined as a (non-static) inner class which means that each Token instance is associated
   * with a specific Scanner instance. We use this when some token methods access the chars array in
   * the associated Scanner.
   * 
   */
  public class Token {
    public final Kind kind;
    public final int pos;
    public final int length;
    public final int line;
    public final int pos_in_line;

    public Token(Kind kind, int pos, int length, int line, int pos_in_line) {
      super();
      this.kind = kind;
      this.pos = pos;
      this.length = length;
      this.line = line;
      this.pos_in_line = pos_in_line;
    }

    public String getText() {
      if (kind == Kind.STRING_LITERAL) {
        return chars2String(chars, pos, length);
      } else
        return String.copyValueOf(chars, pos, length);
    }

    /**
     * To get the text of a StringLiteral, we need to remove the enclosing " characters and convert
     * escaped characters to the represented character. For example the two characters \ t in the char
     * array should be converted to a single tab character in the returned String
     * 
     * @param chars
     * @param pos
     * @param length
     * @return
     */
    private String chars2String(char[] chars, int pos, int length) {
      StringBuilder sb = new StringBuilder();
      for (int i = pos + 1; i < pos + length - 1; ++i) {// omit initial
        // and final "
        char ch = chars[i];
        if (ch == '\\') { // handle escape
          i++;
          ch = chars[i];
          switch (ch) {
            case 'b':
              sb.append('\b');
              break;
            case 't':
              sb.append('\t');
              break;
            case 'f':
              sb.append('\f');
              break;
            case 'r':
              sb.append('\r'); // for completeness, line
              // termination chars not allowed
              // in String literals
              break;
            case 'n':
              sb.append('\n'); // for completeness, line
              // termination chars not allowed
              // in String literals
              break;
            case '\"':
              sb.append('\"');
              break;
            case '\'':
              sb.append('\'');
              break;
            case '\\':
              sb.append('\\');
              break;
            default:
              assert false;
              break;
          }
        } else {
          sb.append(ch);
        }
      }
      return sb.toString();
    }

    /**
     * precondition: This Token is an INTEGER_LITERAL
     * 
     * @returns the integer value represented by the token
     */
    public int intVal() {
      assert kind == Kind.INTEGER_LITERAL;
      return Integer.valueOf(String.copyValueOf(chars, pos, length));
    }

    public String toString() {
      return "[" + kind + "," + String.copyValueOf(chars, pos, length) + "," + pos + "," + length + "," + line
          + "," + pos_in_line + "]";
    }

    /**
     * Since we overrode equals, we need to override hashCode.
     * https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-
     * 
     * Both the equals and hashCode method were generated by eclipse
     * 
     */
    @Override
    public int hashCode() {
      final int prime = 31;
      int result = 1;
      result = prime * result + getOuterType().hashCode();
      result = prime * result + ((kind == null) ? 0 : kind.hashCode());
      result = prime * result + length;
      result = prime * result + line;
      result = prime * result + pos;
      result = prime * result + pos_in_line;
      return result;
    }

    /**
     * Override equals method to return true if other object is the same class and all fields are equal.
     * 
     * Overriding this creates an obligation to override hashCode.
     * 
     * Both hashCode and equals were generated by eclipse.
     * 
     */
    @Override
    public boolean equals(Object obj) {
      if (this == obj)
        return true;
      if (obj == null)
        return false;
      if (getClass() != obj.getClass())
        return false;
      Token other = (Token) obj;
      if (!getOuterType().equals(other.getOuterType()))
        return false;
      if (kind != other.kind)
        return false;
      if (length != other.length)
        return false;
      if (line != other.line)
        return false;
      if (pos != other.pos)
        return false;
      if (pos_in_line != other.pos_in_line)
        return false;
      return true;
    }

    /**
     * used in equals to get the Scanner object this Token is associated with.
     * 
     * @return
     */
    private Scanner getOuterType() {
      return Scanner.this;
    }

  }

  /**
   * Extra character added to the end of the input characters to simplify the Scanner.
   */
  static final char EOFchar = 0;

  /**
   * The list of tokens created by the scan method.
   */
  final ArrayList<Token> tokens;

  /**
   * An array of characters representing the input. These are the characters from the input string
   * plus and additional EOFchar at the end.
   */
  final char[] chars;

  /**
   * position of the next token to be returned by a call to nextToken
   */
  private int nextTokenPos = 0;

  Scanner(String inputString) {
    int numChars = inputString.length();
    this.chars = Arrays.copyOf(inputString.toCharArray(), numChars + 1); // input
    // string
    // terminated
    // with
    // null
    // char
    chars[numChars] = EOFchar;
    tokens = new ArrayList<Token>();
    keywords = new HashMap<>();
    buildMap();
  }

  private void buildMap() {
    keywords.put("x", Kind.KW_x);
    keywords.put("X", Kind.KW_X);
    keywords.put("y", Kind.KW_y);
    keywords.put("Y", Kind.KW_Y);
    keywords.put("r", Kind.KW_r);
    keywords.put("R", Kind.KW_R);
    keywords.put("a", Kind.KW_a);
    keywords.put("A", Kind.KW_A);
    keywords.put("Z", Kind.KW_Z);
    keywords.put("DEF_X", Kind.KW_DEF_X);
    keywords.put("DEF_Y", Kind.KW_DEF_Y);
    keywords.put("SCREEN", Kind.KW_SCREEN);
    keywords.put("cart_x", Kind.KW_cart_x);
    keywords.put("cart_y", Kind.KW_cart_y);
    keywords.put("polar_a", Kind.KW_polar_a);
    keywords.put("polar_r", Kind.KW_polar_r);
    keywords.put("abs", Kind.KW_abs);
    keywords.put("sin", Kind.KW_sin);
    keywords.put("cos", Kind.KW_cos);
    keywords.put("atan", Kind.KW_atan);
    keywords.put("log", Kind.KW_log);
    keywords.put("image", Kind.KW_image);
    keywords.put("int", Kind.KW_int);
    keywords.put("boolean", Kind.KW_boolean);
    keywords.put("url", Kind.KW_url);
    keywords.put("file", Kind.KW_file);
    keywords.put("true", Kind.BOOLEAN_LITERAL);
    keywords.put("false", Kind.BOOLEAN_LITERAL);
  }

  /**
   * Method to scan the input and create a list of Tokens.
   * 
   * If an error is encountered during scanning, throw a LexicalException.
   * 
   * @return
   * @throws LexicalException
   */
  public Scanner scan() throws LexicalException {
    int pos = 0;
    int line = 1;
    int posInLine = 1;
    while (pos < chars.length - 1) {
      switch (chars[pos]) {
        case '\r':
          if (pos + 1 < chars.length - 1 && chars[pos + 1] == '\n') {
            pos += 2;
          } else {
            pos++;
          }
          line++;
          posInLine = 1;
          break;
        case '\n':
          line++;
          pos++;
          posInLine = 1;
          break;
        case '\t':
        case '\f':
        case ' ':
          pos++;
          posInLine++;
          break;
        case '(':
          tokens.add(new Token(Kind.LPAREN, pos++, 1, line, posInLine++));
          break;
        case ')':
          tokens.add(new Token(Kind.RPAREN, pos++, 1, line, posInLine++));
          break;
        case '[':
          tokens.add(new Token(Kind.LSQUARE, pos++, 1, line, posInLine++));
          break;
        case ']':
          tokens.add(new Token(Kind.RSQUARE, pos++, 1, line, posInLine++));
          break;
        case ';':
          tokens.add(new Token(Kind.SEMI, pos++, 1, line, posInLine++));
          break;
        case ',':
          tokens.add(new Token(Kind.COMMA, pos++, 1, line, posInLine++));
          break;
        case '?':
          tokens.add(new Token(Kind.OP_Q, pos++, 1, line, posInLine++));
          break;
        case ':':
          tokens.add(new Token(Kind.OP_COLON, pos++, 1, line, posInLine++));
          break;
        case '&':
          tokens.add(new Token(Kind.OP_AND, pos++, 1, line, posInLine++));
          break;
        case '|':
          tokens.add(new Token(Kind.OP_OR, pos++, 1, line, posInLine++));
          break;
        case '+':
          tokens.add(new Token(Kind.OP_PLUS, pos++, 1, line, posInLine++));
          break;
        case '%':
          tokens.add(new Token(Kind.OP_MOD, pos++, 1, line, posInLine++));
          break;
        case '@':
          tokens.add(new Token(Kind.OP_AT, pos++, 1, line, posInLine++));
          break;
        case '/':
          if (pos + 1 < chars.length - 1 && chars[pos + 1] == '/') {
            pos += 2;
            posInLine += 2;
            while (pos < chars.length - 1 && chars[pos] != '\r' && chars[pos] != '\n' && (int) chars[pos] >= 0
                && (int) chars[pos] <= 127) {
              pos++;
              posInLine++;
            }
          } else {
            tokens.add(new Token(Kind.OP_DIV, pos++, 1, line, posInLine++));
          }
          break;
        case '"':
          int startPos = pos++;
          // String str = "\"";
          boolean isEscapeSequence = false;
          char first = '"';
          char last = '\0';
          int startPosInLine = posInLine++;
          outer: while (pos < chars.length - 1) {
            switch (chars[pos]) {
              case '\n':
              case '\r':
                throw new LexicalException(
                    "String literal on line " + line + " contains invalid character at " + posInLine, pos);
              case '\\':
                // str += '\\';
                posInLine++;
                last = chars[++pos];
                if (last == 'b' || last == 't' || last == 'n' || last == 'f' || last == 'r' || last == '"'
                    || last == '\'' || last == '\\') {
                  // str += last;
                  if (last == '"') {
                    isEscapeSequence = true;
                  }
                  pos++;
                  posInLine++;
                } else
                  throw new LexicalException("Invalid string literal on line " + line + " at " + posInLine,
                      pos);
                break;
              case '"':
                last = '"';
                // str += last;
                pos++;
                isEscapeSequence = false;
                posInLine++;
                break outer;
              default:
                last = chars[pos++];
                posInLine++;
            }
          }

          if (first != '"' || last != '"' || isEscapeSequence) {
            throw new LexicalException("Unclosed string literal on line " + line + " at " + posInLine, pos);
          }
          tokens.add(new Token(Kind.STRING_LITERAL, startPos, pos - startPos, line, startPosInLine));
          break;
        case '-':
          if (pos + 1 < chars.length - 1 && chars[pos + 1] == '>') {
            tokens.add(new Token(Kind.OP_RARROW, pos, 2, line, posInLine));
            pos += 2;
            posInLine += 2;
          } else {
            tokens.add(new Token(Kind.OP_MINUS, pos++, 1, line, posInLine++));
          }
          break;
        case '=':
          if (pos + 1 < chars.length - 1 && chars[pos + 1] == '=') {
            tokens.add(new Token(Kind.OP_EQ, pos, 2, line, posInLine));
            pos += 2;
            posInLine += 2;
          } else {
            tokens.add(new Token(Kind.OP_ASSIGN, pos++, 1, line, posInLine++));
          }
          break;
        case '>':
          if (pos + 1 < chars.length - 1 && chars[pos + 1] == '=') {
            tokens.add(new Token(Kind.OP_GE, pos, 2, line, posInLine));
            pos += 2;
            posInLine += 2;
          } else {
            tokens.add(new Token(Kind.OP_GT, pos++, 1, line, posInLine++));
          }
          break;
        case '<':
          if (pos + 1 < chars.length - 1 && chars[pos + 1] == '=') {
            tokens.add(new Token(Kind.OP_LE, pos, 2, line, posInLine));
            pos += 2;
            posInLine += 2;
          } else if (pos + 1 < chars.length - 1 && chars[pos + 1] == '-') {
            tokens.add(new Token(Kind.OP_LARROW, pos, 2, line, posInLine));
            pos += 2;
            posInLine += 2;
          } else {
            tokens.add(new Token(Kind.OP_LT, pos++, 1, line, posInLine++));
          }
          break;
        case '!':
          if (pos + 1 < chars.length - 1 && chars[pos + 1] == '=') {
            tokens.add(new Token(Kind.OP_NEQ, pos, 2, line, posInLine));
            pos += 2;
            posInLine += 2;
          } else {
            tokens.add(new Token(Kind.OP_EXCL, pos++, 1, line, posInLine++));
          }
          break;
        case '*':
          if (pos + 1 < chars.length - 1 && chars[pos + 1] == '*') {
            tokens.add(new Token(Kind.OP_POWER, pos, 2, line, posInLine));
            pos += 2;
            posInLine += 2;
          } else {
            tokens.add(new Token(Kind.OP_TIMES, pos++, 1, line, posInLine++));
          }
          break;
        case '0':
          tokens.add(new Token(Kind.INTEGER_LITERAL, pos++, 1, line, posInLine++));
          break;
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          String integer = "" + chars[pos];
          startPos = pos++;
          startPosInLine = posInLine++;
          while (pos < chars.length - 1 && chars[pos] >= '0' && chars[pos] <= '9') {
            integer += chars[pos++];
            posInLine++;
          }
          if (!isValidInteger(integer)) {
            throw new LexicalException("Integer exceeds max value on line " + line + " at pos " + posInLine,
                pos);
          } else {
            tokens.add(new Token(Kind.INTEGER_LITERAL, startPos, pos - startPos, line, startPosInLine));
          }
          break;
        default:
          // System.out.println(pos + " " + chars[pos]);
          String str = "";
          if (isIdentifierStart(chars[pos])) {
            str += chars[pos];
            startPos = pos++;
            startPosInLine = posInLine++;
            while (pos < chars.length - 1 && isIdentifierPart(chars[pos])) {
              str += chars[pos++];
              posInLine++;
            }
            Kind kind = Kind.IDENTIFIER;
            if (keywords.containsKey(str)) {
              kind = keywords.get(str);
            }
            tokens.add(new Token(kind, startPos, pos - startPos, line, startPosInLine));
          } else
            throw new LexicalException(
                "Invalid character " + chars[pos] + " on line " + line + " at pos " + posInLine, pos);
      }
    }
    tokens.add(new Token(Kind.EOF, pos, 0, line, posInLine));
    return this;

  }

  private boolean isValidInteger(String str) {
    try {
      int val = Integer.valueOf(str);
    } catch (NumberFormatException n) {
      return false;
    }
    return true;

  }

  private boolean isIdentifierStart(char c) {
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_' || c == '$';
  }

  private boolean isIdentifierPart(char c) {
    return isDigit(c) || isIdentifierStart(c);
  }

  private boolean isDigit(char c) {
    return c >= '0' && c <= '9';
  }

  /**
   * Returns true if the internal iterator has more Tokens
   * 
   * @return
   */
  public boolean hasTokens() {
    return nextTokenPos < tokens.size();
  }

  /**
   * Returns the next Token and updates the internal iterator so that the next call to nextToken will
   * return the next token in the list.
   * 
   * It is the callers responsibility to ensure that there is another Token.
   * 
   * Precondition: hasTokens()
   * 
   * @return
   */
  public Token nextToken() {
    return tokens.get(nextTokenPos++);
  }

  /**
   * Returns the next Token, but does not update the internal iterator. This means that the next call
   * to nextToken or peek will return the same Token as returned by this methods.
   * 
   * It is the callers responsibility to ensure that there is another Token.
   * 
   * Precondition: hasTokens()
   * 
   * @return next Token.
   */
  public Token peek() {
    return tokens.get(nextTokenPos);
  }

  /**
   * Resets the internal iterator so that the next call to peek or nextToken will return the first
   * Token.
   */
  public void reset() {
    nextTokenPos = 0;
  }

  /**
   * Returns a String representation of the list of Tokens
   */
  public String toString() {
    StringBuffer sb = new StringBuffer();
    sb.append("Tokens:\n");
    for (int i = 0; i < tokens.size(); i++) {
      sb.append(tokens.get(i)).append('\n');
    }
    return sb.toString();
  }

}
